---
description: "Performance optimization: RxDart for reactive streams, Isolates for heavy computation, multi-threading for video processing, and optimization strategies."
globs:
  - "lib/**/*.dart"
alwaysApply: false
---

# Performance Optimization

## RxDart for Reactive Streams

- Use BehaviorSubject for state (has current value)
- Use PublishSubject for events (no current value)
- Combine multiple streams with `Rx.combineLatest`
- Debounce user input: 300ms delay
- Throttle frequent updates: 1s interval
- Use `distinct()` to skip duplicates
- Use `shareReplay()` for expensive streams
- Always close subjects in dispose()

## Isolates for Heavy Computation

**When to use Isolates:**
- Video frame decoding/encoding
- AI model inference
- Image processing (resize, filter)
- Large data parsing (JSON, CSV)
- Cryptography operations
- Any CPU-intensive task > 16ms

**How to use:**
- Use `compute()` for simple one-off tasks
- Use `Isolate.spawn()` for long-running operations
- Pass data through SendPort/ReceivePort
- Limit active isolates (max = CPU cores)
- Dispose isolates when done

## Multi-Threading for Video

- Process video frames in dedicated Isolate
- Use object pooling for frame buffers
- Parallel processing for multiple cameras
- Limit frame rate: 30 FPS max for processing
- Skip frames if processing can't keep up
- Use Platform.numberOfProcessors for thread count

## Widget Performance

- Always use const constructors
- Add keys to list items: ValueKey(item.id)
- Use RepaintBoundary for expensive widgets
- Use AutomaticKeepAliveClientMixin for tabs
- Extract widgets instead of helper methods
- Avoid rebuilding entire tree (use Builder)
- Use ListView.builder (not ListView)
- Implement shouldRepaint in CustomPainter

## Memory Management

- Dispose ALL controllers in dispose()
- Cancel timers: `timer?.cancel()`
- Close streams: `controller.close()`
- Cancel subscriptions: `subscription.cancel()`
- Remove listeners: `removeListener()`
- Clear caches periodically
- Use WeakReference for optional caching
- Implement object pooling for frequent allocations

## Network Optimization

- Batch multiple API calls into one
- Debounce search queries (300ms)
- Use CancelToken for cancellable requests
- Cache network responses with TTL
- Compress images before upload
- Use pagination for large lists
- Set appropriate timeouts
- Retry with exponential backoff

## Stream Processing

- Use StreamTransformer for reusable logic
- Buffer events: `bufferTime()`, `bufferCount()`
- Sample periodic: `sampleTime()`
- Skip unnecessary events: `where()`, `distinct()`
- Limit stream rate: `throttleTime()`, `debounceTime()`
- Handle backpressure appropriately

## Build Performance

- Minimize build() method size (< 50 lines)
- Avoid expensive operations in build()
- Cache computed values
- Use `const` for static widgets
- Extract complex widgets to separate classes
- Use `Builder` to scope rebuilds
- Profile widget rebuilds with DevTools

## Image & Video

- Use CachedNetworkImage for network images
- Resize images before display
- Use appropriate image formats (WebP)
- Limit video resolution (1080p max)
- Use hardware decoder when available
- Clear image cache when low memory
- Preload critical images

## Profiling & Monitoring

**Before optimizing:**
- Profile with DevTools Performance tab
- Use Timeline for specific operations
- Monitor frame rendering (target: 60 FPS)
- Check memory usage (avoid leaks)
- Measure build times
- Identify hot spots

**Tools:**
- `developer.Timeline.startSync()`
- `SchedulerBinding.addTimingsCallback()`
- DevTools Memory tab
- DevTools Performance tab

## Quick Optimization Checklist

- ✅ RxDart for reactive streams
- ✅ Isolates for CPU-intensive work
- ✅ const constructors everywhere
- ✅ Keys on list items
- ✅ RepaintBoundary on expensive widgets
- ✅ Dispose all resources
- ✅ Batch network requests
- ✅ Debounce user input
- ✅ Object pooling for allocations
- ✅ Profile before optimizing
