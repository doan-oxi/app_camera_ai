---
description: "Flutter and Dart best practices for widgets, state management, performance optimization, and reactive programming with RxDart."
globs:
  - "lib/**/*.dart"
  - "test/**/*.dart"
alwaysApply: false
---

# Flutter & Dart Best Practices

## Widget Guidelines

- Prefer StatelessWidget over StatefulWidget when possible
- Use StatefulWidget only for local UI state (animation, focus, scroll)
- Never put business logic in widgets
- Extract reusable widgets to separate files
- Use const constructors wherever possible
- Add keys to list items (ValueKey)
- One widget per file (except private helper widgets)
- Keep build() method < 50 lines

## State Management

- Use Bloc/Cubit for business state
- Use Provider/GetIt for dependency injection
- Never create Bloc instances in build() method
- Always dispose Blocs when done
- Use StreamBuilder for reactive UI
- Use BlocBuilder/BlocConsumer for Bloc state
- Never mutate state directly (always emit new state)
- Keep state classes immutable

## Async/Await

- Always use async/await for asynchronous operations
- Handle errors with try-catch
- Never use `.then()` chains (use async/await instead)
- Use Future.wait() for parallel operations
- Set timeouts for network operations
- Use CancelToken for cancellable operations
- Never block UI thread

## Streams & RxDart

- Use BehaviorSubject for state streams
- Use PublishSubject for events
- Combine streams with Rx.combineLatest
- Debounce user input (300ms)
- Throttle frequent updates (1s)
- Always close StreamControllers in dispose()
- Use shareReplay() for expensive streams
- Use distinct() to avoid duplicate emissions

## Performance

- Use const constructors
- Add RepaintBoundary for expensive widgets
- Use AutomaticKeepAlive for tabs
- Lazy load images with CachedNetworkImage
- Use ListView.builder (not ListView)
- Limit list items (pagination)
- Use compute() for CPU-intensive work
- Profile before optimizing (DevTools)

## Null Safety

- Use null-aware operators (`?.`, `??`, `??=`)
- Avoid force unwrap (`!`) unless certain
- Use `late` for deferred initialization
- Check null before accessing
- Prefer nullable types over default values
- Use `required` for mandatory parameters

## Code Organization

- Group imports: Dart SDK → Flutter → Third-party → Local
- Use barrel exports (`lib/core/core.dart`)
- One class per file
- File name = class name in snake_case
- Keep files < 300 lines

## Error Handling

- Catch specific exception types
- Provide user-friendly error messages
- Log errors with context
- Never swallow exceptions silently
- Use try-catch-finally for cleanup
- Handle network timeouts
- Validate input before processing

## Reactive Programming

- Use StreamBuilder for continuous data
- Use FutureBuilder for one-time async data
- Dispose subscriptions in dispose()
- Use StreamSubscription.cancel()
- Avoid nested StreamBuilders
- Use Rx operators for transformation

## Best Practices

- Use extension methods for utilities
- Use mixins for shared behavior
- Prefer composition over inheritance
- Keep functions pure when possible
- Avoid global state
- Use dependency injection
- Write testable code
- Document complex logic
