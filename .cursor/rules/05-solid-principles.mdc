---
description: "SOLID principles with detailed examples for Clean Architecture. Apply to all layers but especially important in domain and data layers."
globs:
  - "lib/**/*.dart"
  - "android/**/*.kt"
  - "ios/**/*.swift"
alwaysApply: false
---

# SOLID Principles

## S - Single Responsibility Principle

**One class = one reason to change**

- Each class should have only ONE responsibility
- Separate concerns: connection, persistence, analytics, UI
- Split large classes into smaller, focused ones
- UseCases should do ONE thing only
- Example: ConnectCameraUseCase (only connects), SaveCameraUseCase (only saves)

## O - Open/Closed Principle

**Open for extension, closed for modification**

- Use interfaces/abstractions for flexibility
- Extend behavior through inheritance/composition
- Don't modify existing code to add features
- Use strategy pattern for varying behavior
- Example: VideoSource interface with LiveStream, TFCard, Network implementations

## L - Liskov Substitution Principle

**Subtypes must be substitutable for base types**

- Child classes must work wherever parent class works
- Don't throw NotImplemented in subclasses
- Don't change expected behavior in subclasses
- Maintain interface contracts
- Example: All Camera subtypes must support connect/disconnect

## I - Interface Segregation Principle

**Many small interfaces > one large interface**

- Split large interfaces into smaller, specific ones
- Clients should not depend on unused methods
- Use mixins for optional capabilities
- Example: Connectable, Streamable, PTZControllable instead of one CameraDevice interface

## D - Dependency Inversion Principle

**Depend on abstractions, not concretions**

- High-level modules depend on abstractions
- Low-level modules implement abstractions
- Use repository interfaces in domain layer
- Implement interfaces in data/infrastructure layers
- Inject dependencies through constructors
- Example: CameraBloc depends on CameraRepository (interface), not VeepaiCameraRepository (implementation)

## Quick Reference

Ask these questions:

| Principle | Question |
|-----------|----------|
| **S**RP | Does this class have more than one reason to change? |
| **O**CP | Do I need to modify this class to add new behavior? |
| **L**SP | Can I replace the parent with this child class? |
| **I**SP | Does this interface force clients to implement unused methods? |
| **D**IP | Am I depending on concrete classes instead of abstractions? |

## Common Violations to Avoid

- ❌ Multiple responsibilities in one class
- ❌ Modifying existing code to add features
- ❌ Child classes changing expected behavior
- ❌ Fat interfaces with many methods
- ❌ Depending on concrete implementations
- ❌ Creating dependencies in wrong direction

## Application in Project

- **Domain Layer**: All SOLID principles critical here
- **Data Layer**: Focus on SRP, DIP
- **Presentation Layer**: Focus on SRP, DIP
- **Infrastructure Layer**: Focus on OCP, ISP
